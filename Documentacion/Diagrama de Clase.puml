@startuml
skinparam classAttributeIconSize 0

package Pregunta {
    interface Observable {
        + notifyObservers()
        + addObserver(Observer observer)
    }
    abstract class Pregunta {
        # enunciado: String
        # opciones: List<String>
        # respuestaCorrecta: Respuesta
        # observers: ArrayList<Observer>
        # responder(List<Respuesta> respuestas): List<Integer>
        # getEnunciado(): String
    }
    class PreguntaMultipleChoice {
        - PreguntaMultipleChoice(...)
        + {static} Parcial(...): PreguntaMultipleChoice
        + {static} Penalidad(...): PreguntaMultipleChoice
        + {static} Clasico(...): PreguntaMultipleChoice
        + observers: ArrayList<Observer>
        + responder(List<Respuesta> respuestas): List<Integer>
        + getEnunciado(): String
        + notifyObservers()
        + addObserver(Observer observer)
    }
    class PreguntaVerdaderoFalso {
        - PreguntaVerdaderoFalso(...)
        + {static} Penalidad(...): PreguntaVerdaderoFalso
        + {static} Clasico(...): PreguntaVerdaderoFalso
        + responder(List<Respuesta> respuestas): List<Integer>
        + getEnunciado(): String
        + notifyObservers()
        + addObserver(Observer observer)
    }
    class PreguntaGroupChoice {
        + PreguntaGroupChoice(...)
        + responder(List<Respuesta> respuestas): List<Integer>
        + getEnunciado(): String
        + notifyObservers()
        + addObserver(Observer observer)
    }
    class PreguntaOrderedChoice {
        + PreguntaOrderedChoice(...)
        + responder(List<Respuesta> respuestas): List<Integer>
        + getEnunciado(): String
        + notifyObservers()
        + addObserver(Observer observer)
    }
}

package Puntaje {
    interface Puntaje {
        + {static} ParaVerdaderoFalso(): PuntajeClasico
        + {static} ParaMultipleChoice(): PuntajeClasico
        + puntuar(List<Integer> evaluacion): Integer
    }
    class PuntajeClasico {
        - aciertosEsperados: int
        + puntuar(List<Integer> evaluacion): Integer
    }
    class PuntajeParcial {
        + puntuar(List<Integer> evaluacion): Integer
    }
    class PuntajePenalidad {
        + puntuar(List<Integer> evaluacion): Integer
    }
}

package AlgoKahoot {
    class Jugador {
        - nombre: String
        - puntaje: int
        - usosDisponiblesExclusividad: int
        + nombre(): String
        + nombrar(nombre: String)
        + puntuar(puntos: int)
        + puntaje(): int
        + usarMultiplicador(valor: int)
        + usarExclusividad()
    }
}

package Puntuadores {
    class ExclusividadDePuntaje {
        - valor: int
        + calcularPuntos(List<Integer> puntos): List<Integer>
        + usarExclusividad(Jugador jugador): ExclusividadDePuntaje
    }
    class Multiplicador {
        - valor: int
        - usosDisponibles: int
        + usar()
        + multiplicar(unPuntaje: Integer): Integer
    }
    class Puntuador {
        + asignarPuntos(List<Integer> puntos)
        + calcularPuntos(List<Integer> puntos): List<Integer>
        + usarExclusividad(Jugador jugador): ExclusividadDePuntaje
    }
}

package Respuesta {
    interface Respuesta {
        + evaluar(Respuesta respuestaUsuario): List<Integer>
    }
    class RespuestaGroupChoice {
        - equals(Set<Integer> grupoA, Set<Integer> grupoB): boolean
        + equals(RespuestaGroupChoice otraRespuesta): boolean
        + evaluar(Respuesta respuestaUsuario): List<Integer>
    }
    class RespuestaMultipleChoice {
        - intersection(Set<Integer> opciones): Set<Integer>
        + intersection(RespuestaMultipleChoice respuesta): Set<Integer>
        + size(): Integer
        + evaluar(Respuesta respuestaUsuario): List<Integer>
    }
    class RespuestaVerdaderoFalso {
        - equals(boolean otraRespuesta): boolean
        + equals(RespuestaVerdaderoFalso otraRespuesta): boolean
        + evaluar(Respuesta respuestaUsuario): List<Integer>
    }
    class RespuestaOrderedChoice {
        - equals(List<Integer> otraRespuesta): boolean
        + equals(RespuestaOrderedChoice otraRespuesta): boolean
        + evaluar(Respuesta respuestaUsuario): List<Integer>
    }
}

'Ordenamiento De Cuadrados
RespuestaMultipleChoice -[hidden]down-> Jugador
RespuestaVerdaderoFalso -[hidden]down-> Jugador
RespuestaOrderedChoice -[hidden]down-> Jugador

'Herencia --|> cumple la relación 'es un'
ExclusividadDePuntaje --|> Puntuador

'Asociacion --> un objeto guarda a otro
Puntuador -left-> "*" Jugador
Pregunta -down-> Respuesta

'Agregacion --o un objeto esta compuesto por otro pero no lo necesita para vivir
Jugador "1" o-- "3" Multiplicador

'Composicion --* un objeto es dueño de otro
Puntaje *-- PreguntaVerdaderoFalso
Puntaje *-- PreguntaMultipleChoice

'Dependencia ..> un objeto utiliza a otro porque lo recibe/devuelve
Puntuador ..> ExclusividadDePuntaje

'Interfaces ..|> colección de declaraciones de métodos sin implemetnar
Observable <|.left. Pregunta
PreguntaGroupChoice .down.|> Pregunta
PreguntaMultipleChoice .down.|> Pregunta
PreguntaVerdaderoFalso .down.|> Pregunta
PreguntaOrderedChoice .down.|> Pregunta
Respuesta <|.. RespuestaGroupChoice
Respuesta <|.. RespuestaMultipleChoice
Respuesta <|.. RespuestaOrderedChoice
Respuesta <|.. RespuestaVerdaderoFalso
PuntajeClasico ..|> Puntaje
PuntajeParcial ..|> Puntaje
PuntajePenalidad ..|> Puntaje
@enduml